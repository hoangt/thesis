\section{Methodology}

While computer architecture simulators have been around for quite some time,
energy estimation techniques is a more recent necessity. Song et. al
\cite{song2012instruction} identifies three major approaches to processor power
modelling used in the past, and introduces an instruction-based energy
estimation model that can be used for energy simulation at high speed. Their
proposed method is expressed through the following equation and includes the
desired features of past energy models.

\[
    P_{core}(t) = \frac{E_{unit} \cdot A_{datapath} \cdot w(t) +
    E_{static}}{T_{sampling}}
\]

This method depends on two things. First, one must know sufficient details of
the processor to identify datapath components in order to form the
$A_{datapath}$ matrix. Secondly, the energy unit vector $E_{unit}$ requires
circuit-level knowledge of the target processor. The former information can
often be found by reverse engineering and benchmarking, however, the latter is
rarely available for commercial processors. When building the model for PET, we
simplify the model from \cite{song2012instruction} by combining $A_{datapath}$
and $E_{unit}$ to form a vector of weights that directly corresponds to the cost
of an event. We can then model energy by the following formula.

\[
    P_{core}(t) = \frac{C \cdot w(t) + E_{static}}{T_{sampling}}
\]

Here, C represents the global cost vector -- a matrix enumerating the cost
for all event types. Please note that it is global and do not depend on time.

The choice of events/workload metrics is an important part of our method. We
account for two types of events; CPU instruction events and memory activity
events.

A major design choice made on how PET should be designed was to decide whether
it should be a standalone program or incorporated into an existing simulator.
There already exists a lot of computer architecture simulators, all with
strengths and weaknesses. Often, simulators only supports a small set of
architectures, memory systems and CPU models, and they only excel in simulating
one specific combination.

\subsection{A Brief Comparison of Simulators}
\label{subsec:simulators}
There are numerous Computer Architecture Simulators available to the
public, both commercial, free and open source alternatives exists. In order
to estimate power consumption, the simulator needs to be able to give a good estimate
of the events which will happen in the hardware implementation of the architecture,
as this is the base for the calculations. The hardware platform used in this thesis
is an out-of-order ARM Cortex-A9 based core fitted with memory and and peripherals
in a von Neumann architectural scheme. The out-of-order propery significantly
increases the level of complexity which the simulator must handle.

\begin{description}
\item[Sniper] \hfill\\
    Sniper is a high-speed, multicore, multi-threaded and cycle-accurate computer
    architecture simulator \cite{sniperwebpage,carlson2013ssomta}. It already integrates with McPAT, and it is open source.
    Sniper does only work x86, and is thus not applicable for simulation of ARM-based
    architectures.

\item[SimpleScalar] \hfill\\
    SimpleScalar is a popular commercial architectural simulator that comes with a free academic
    license providing full source code. SimpleScalar supports the ARM instruction set amongst many others,
    and looks like a decent simulator for advanced out-of-order core simulation. SimpleScalar is
    also the simulator used by the Wattch-project \cite{brooks2000wattch}. However, the SimpleScalar
    web page seems to be last updated in 2004 and all mailing list archives are gone for the moment of
    writing. The source code for SimpleScalar v3 was still available and has been changed in 2011, but
    the entire SimpleScalar core has not changed since 2003.

\item[QEMU]\hfill\\
    QEMU is a generic and open machine emulator witch enables near real-time performance on
    architectures such as ARM, even when the host machine is running x86. However, QEMU is a machine emulator
    rather than an architectural simulator, thus despite it's great performance of running ARM-binaries, it
    will not produce CPU and memory event trace logs, and cannot be used in this project.

\item[gem5]\hfill\\
    gem5 is a merger \cite{gem5hipeac} between the M5 simulator \cite{binkert2006m5} project and the GEMS simulator project \cite{GEMS}. gem5 provides
    ARM-support with out-of-order execution out of the box, and provide great and cycle-accurate
    trace logs which is very applicable for this project \cite{gem5simulator}. gem5 is written in C and is configured
    with Python scripts, which makes it not so difficult to extend or change. Many of the maintainers
    are employees of ARM Corp., and the activity on the mailing lists suggests high project activity \cite{gem5dev}.

\end{description}

Provided this comparison of simulators, and given the fact that NTNU has a tradition
for using M5 and gem5 in earlier research projects and subjects, gem5 is the natural
winner for the choise of an architectural simulator.


\subsection{Power Consuming Events}
\label{subsec:powerevents}
It is desirable to estimate energy consumption on literally all types of
compututing systems, ranging from large-size clusters to embedded systems. To
provide this flexibility it was decided to write the tool as simulator agnostic
as possible, tracking \emph{simulator events} rather than executed instructions.
A simulator event is defined as a unit of work that uses a specified amount of
energy, and increases modelled energy consumption to the simulated time. We
defined a set of simulator events that PET should consider. The selected events
are briefly described in \autoref{tbl:events}.

\begin{table}[ht]
    \centering
    \begin{minipage}[b]{\linewidth}
        \centering
        \begin{tabular}{|l|l|}
            \hline
            IntAlu    & Integer basic ALU operation\\
            \hline
            IntMult    & Integer multiply ALU operation \\
            \hline
            MemRead    & Memory Read issued, triggers LS-unit \\
            \hline
            MemWrite    & Memory Write issued, triggeres LS-unit \\
            \hline
            SimdFloatMisc     & NEON-unit activated \\
            \hline
        \end{tabular}
        \subcaption{CPU Core Events}
    \end{minipage}

    \begin{minipage}[b]{\linewidth}
        \centering
        \begin{tabular}{|l|l|}
            \hline
            L1IR    & L1 instruction cache, read \\
            \hline
            L1IW    & L1 instruction cache, write \\
            \hline
            L1DR    & L1 data cache, read \\
            \hline
            L1DW    & L1 data cache, write \\
            \hline
            L2R     & L2 cache, read \\
            \hline
            L2W     & L2 cache, write \\
            \hline
            PhysR   & Main memory, read \\
            \hline
            PhysW   & Main memory, write \\
            \hline
        \end{tabular}
        \subcaption{Memory Events}
    \end{minipage}
    \caption{Power Consuming Events}
    \label{tbl:events}
\end{table}


gem5 was used as a basis for development and the only simulation front-end
implemented.




- ARM support (Sniper has not)

QEMU -- feil abstraksjonsnivå/formål
McPat - multicore, power AND AREA???? Optimizer
CACTI - cache power estimation
gem5 is flexible because
- it is easy to add new processor architectures
- memory system
=> in-house experience

LLVM traces?

