\section{Methodology}

\subsection{Design Choices}
\label{subsec:design_choices}
The first choices made on how PET should be designed was to decide whether it
should be a standalone program or incorporated into an existing simulator.
Hundreds of computer architecture simulators exists, all with strengths and
weaknesses. Often, simulators only supports a small set of architectures, memory
systems and CPU models, and they only excel in simulating one specific
combination.

It is desirable to estimate energy consumption on literally all types of
compututing systems, ranging from large-size clusters to embedded systems. To
provide this flexibility it was decided to write the tool as simulator agnostic
as possible, tracking \emph{simulator events} rather than executed instructions.
A simulator event is defined as a unit of work that uses a specified amount of
energy, and increases modelled energy consumption to the simulated time. We
defined the following set of simulator events PET should consider.

\begin{center}
    \begin{tabular}{|l|l|}
        \hline
        L1IR    & L1 instruction cache, read \\
        \hline
        L1IW    & L1 instruction cache, write \\
        \hline
        L1DR    & L1 data cache, read \\
        \hline
        L1DW    & L1 data cache, write \\
        \hline
        L2R     & L2 cache, read \\
        \hline
        L2W     & L2 cache, write \\
        \hline
        PhysR   & Main memory, read \\
        \hline
        PhysW   & Main memory, write \\
        %Null
        \hline
    \end{tabular}
\end{center}

gem5 was used as a basis for development and the only simulation front-end
implemented.




- ARM support (Sniper has not)

QEMU -- feil abstraksjonsnivå/formål
McPat - multicore, power AND AREA???? Optimizer
gem5 is flexible because
    - it is easy to add new processor architectures
    - memory system
=> in-house experience

LLVM traces?

