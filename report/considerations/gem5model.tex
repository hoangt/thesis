\section{Simulator Environment}

PET relies heavily on a front-end that can execute a binary on a simulator and
output $(time, event)$ tuples to a trace file. We are using the gem5 simulator,
but technically PET could be modified to support any simulator front-end.
The power profile generated by PET are derived from the weight configuration
given as input and the simulation trace, so it is important that the simulator
trace is similar to a hardware execution.

Butko et al. \cite{butko2012accuracy} reports gem5 accuracy to vary from 1.39\%
to 17.94\%, with the most accurate results coming from programs with low memory
usage. The benchmarks used represents a wide variety of scientific workloads,
media applications and memory intensive benchmarks. The program execution has a
high degree of instruction diversity, so they get away with having a very simple
CPU model. The real program flow gets diluted and accurate timings are obtained
simply by setting the correct CPI value. In fact, they even use an in-order
model to simulate an out-of-order core.

We claim that the key to obtain high precision power estimates is an
architectural simulator with great accuracy. The simulator must exhibit similar
timing characteristics as the target hardware under all workloads considered,
such that the simulated execution resembles the hardware execution as much as
possible. The scheme suggested in this thesis is based on accumulation of
discrete events, each with an assigned weight according to its contribution to
the global power consumption. This means that accurate power estimation needs
these discrete events to happen, and they must happen with a realistic timing
related to their triggering cause.

Without a simulator capable of providing decent accuracy over system events,
power estimation using methods as suggested in this report will fail. We will
now explain how gem5 can be configured to improve simulator accuracy for a
particular CPU core, as well as pointing out difficulties with this approach.


\subsection{gem5 CPU model}
The revision of gem5 used for these experiments, changeset aaf017eaad7d,
contains a decent model for the ARM Cortex-A9 processor. Actually, the
implemented CPU is a generic out-of-order processor capable of running the ARMv7
ISA, which is equal to that of ARM Cortex-A9\cite{armtech}. The performance of
the ARM Cortex-A9 will differ between its implementations, and to make it even
harder, most vendors will not disclose details to the public. It has been
discussed among the gem5 users wherever the default configuration for this
processor actually is equal to any real processor\cite{a15maillist}, but the
general answer is that no one knows or are allowed to tell.

The goal of this project it to be able to estimate power for new architectures
that might or might not be close to existings architectures, but as a reference
for the implementation, a good model for a known processor is needed. The
hardware platform and the experimental setup is equalt to that in
\cite{rundehvatum2013exploring}, so gem5 must be adapted to simulate a Samsung
Exynos 4412P, or at least the CPU-part of it.  gem5 is made to be adapted, so
adaption is mostly done through editing python files. A new file was created in
\texttt{gem5/configs/common/Exynos\_4412P.py} and a few others were edited to
include this new processor definition. The processor definition used and other
modifications done to the original changeset aaf017eaad7d can be found in
\autoref{apx:gem5files}.

As a decent amount of implementation details often are keept secret from end users, it
is not trivial to model any commercial processor. To get as equal as possible performance
and event scheduling to the real hardware, parameters was fetched from around the Internet,
and the simulator was then scripted to run with a wide variaty of configurations and
mutations of these, all for the ARM Out-of-order CPU model. When the run time performance was
as good as time permitted, the configuration was accepted and used further in the experiment.
This final configuration is the one printed in \autoref{gem5exynos4412p}. Sources suggesting
parameters for ARM Cortex-A9 or Samsung Exynos 4412P is listed in \autoref{fig:a9paramsources}

\begin{figure}
All web references was found between january and april 2014.
\begin{itemize}
    \item{\cite{blem2013detailed}}
    \item{\cite{butko2012accuracy}}
    \item{\cite{armtech}}
    \item{\url{http://en.wikipedia.org/wiki/Odroid}}
    \item{\url{http://en.wikipedia.org/wiki/Exynos}}
    \item{\url{http://www.geekland.co/ARM-Cortex-A9-Exynos-Quad-Core-4412-Android-Development-Board-GK-4412P.htm}}
    \item{\url{http://www.7-cpu.com/cpu/Cortex-A9.html}}
    \item{\url{http://www.arm.com/products/processors/cortex-a/cortex-a9.php?tab=Specifications}}
\end{itemize}
\caption{Sources suggesting parameters for ARM Cortex-A9 or Samsung Exynos 4412P}
\label{fig:a9paramsources}
\end{figure}


\subsection{gem5 memory model}
We did not use Ruby.
