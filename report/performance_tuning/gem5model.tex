\section{Simulator Environment}

PET relies heavily on a front-end that can execute a binary on a simulator and
output $(time, event)$ tuples as a trace of execution. In this thesis, we are
using the gem5 simulator, but technically PET could be modified to support any
simulator front-end. The power profile generated by PET are derived from the
weight configuration given as input and the simulation trace, so it is important
that the simulator trace is similar to a hardware execution.

Butko et al. \cite{butko2012accuracy} reports gem5 \emph{runtime} accuracy to
vary from 1.39~\% to 17.94~\%, with the most accurate results coming from
programs with low memory usage. The benchmarks used represents a wide variety of
scientific workloads, as well as media applications and memory intensive
synthetic benchmarks. The benchmarks used has a high degree of instruction
diversity, so they get away with having a simple CPU model. The real program
flow gets diluted and accurate timings are obtained simply by setting the
correct CPI value. In fact, they used an in-order model to simulate an
out-of-order core.

We claim that the key to obtain high precision power estimates is an
architectural simulator with great accuracy. The simulator must exhibit similar
timing characteristics as the target hardware under all workloads considered,
such that the simulated execution resembles the hardware execution as close as
possible. This means that accurate power estimation needs these discrete events
to happen, and they must happen with a realistic timing related to their
triggering cause. Without a simulator capable of providing decent accuracy over
system events, power estimation using methods as suggested in this report will
fail. We will now explain how gem5 can be configured to improve simulator
accuracy for a particular CPU core, as well as pointing out difficulties with
this approach.


\subsection{gem5 CPU configuration}
The gem5 simulator is bundled with an out-of-order core implementing the ARMv7
ISA. It serves as a basis for the evolution of our custom core meant to model a
Cortex-A9 on the Exynos~4412 SoC. ARM cores can be configured with caches of
varying sizes decided by the implementing vendor and will have varying
performance accordingly. Thus, it is important to tune all CPU parameters so
that it matches the modeled SoC. It is not publicly known which SoC the default
configuration attempts to model, but according to the gem5 mailing list it is
neither Cortex-A9 nor Cortex-A15 \cite{a15maillist}. However, the fact that it
is made for the ARMv7 instruction set and is out-of-order leads us to think that
minor modifications will make it a decent Cortex-A9 model.

The model gem5 uses in its simulations can easily be configured using a Python
interface. We started with gem5 changeset \texttt{aaf017eaad7d} and added a new
CPU configuration file for the Exynos~4412;
\texttt{gem5/configs/common/Exynos\_4412P.py}. A few other files were edited to
accommodate the new processor definition. Please refer to
\autoref{apx:gem5files} to see all patches applied in these experiments.

We found many sources of information claiming to know implementation details of
the Cortex-A9, including
\cite{butko2012accuracy,blem2013detailed,armtech,exynoswiki,odroidwiki,geekland,7cpu,armcortexa9specs}.

Combining this information helps us build a gem5 model for the Exynos SoC, but
it is still not trivial.  We found the simulator to perform different from the
physical hardware, even though the system parameters were set equal. We claim
that this is due to the abstraction the simulator provides us; the simulator is
not a complete model of the hardware. Gibson et. al. \cite{gibson2000flash} have
done a similar experiment using different simulators and concluded that bugs and
omissions in system simulators may render accuracy tuning difficult.

To improve our results, we adjusted the model specification such that it
\textit{performed} similar to the hardware, i.e., programs executed in about the
same number of clock cycles. Even if the processor implementation would have
been completely transparent, it would still be hard to leverage the use of a
multi-architecture computer simulator. Features such as fast-loop mode found in
certain ARM cores must have a corresponding implementation in the simulator for
complete correctness; it would be infeasible to include such details in a
general simulator.

We scripted the simulator to run a wide variety of configurations, about $50$ in
total. We evaluated their performance by comparing simulated execution time to
execution time on real hardware. Real execution time was inferred by measuring
power during program executions and identifying when the CPU was working. The
final CPU configuration is shown in its entirety in \autoref{gem5exynos4412p}.


\subsection{gem5 Memory Model}
The memory system is an important part of a system simulator when doing
performance estimations. At the time of writing, gem5 will not easily work with
an out-of-order CPU model together with the GEMS Ruby memory system. Lacking
other methods and considering our resources, the simple memory system will
provide events that PET can use to determine memory and memory bus
communications. The simple memory model was tuned as shown in
\autoref{gem5simpledram}.
