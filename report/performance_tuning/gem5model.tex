\section{Simulator Environment}

PET relies heavily on a front-end that can execute a binary on a simulator and
output $(time, event)$ tuples as a trace of execution. In this thesis, we are
using the gem5 simulator, but technically PET could be modified to support any
simulator front-end. The power profile generated by PET are derived from the
weight configuration given as input and the simulation trace, so it is important
that the simulator trace is similar to a hardware execution.

Butko et al. \cite{butko2012accuracy} reports gem5 \emph{runtime} accuracy to
vary from 1.39~\% to 17.94~\%, with the most accurate results coming from
programs with low memory usage. The benchmarks used represents a wide variety of
scientific workloads, as well as media applications and memory intensive
synthetic benchmarks. The program execution for their benchmarks has a high
degree of instruction diversity, so they get away with having a very simple CPU
model. The real program flow gets diluted and accurate timings are obtained
simply by setting the correct CPI value. In fact, they even use an in-order
model to simulate an out-of-order core.

We claim that the key to obtain high precision power estimates is an
architectural simulator with great accuracy. The simulator must exhibit similar
timing characteristics as the target hardware under all workloads considered,
such that the simulated execution resembles the hardware execution as close as
possible. This means that accurate power estimation needs these discrete events
to happen, and they must happen with a realistic timing related to their
triggering cause. Without a simulator capable of providing decent accuracy over
system events, power estimation using methods as suggested in this report will
fail. We will now explain how gem5 can be configured to improve simulator
accuracy for a particular CPU core, as well as pointing out difficulties with
this approach.


\subsection{gem5 CPU configuration}
The gem5 simulator is bundled with an out-of-order ARMv7 core and serves as a
basis for the evolution of our custom core meant to model an Cortex-A9 core on
the Exynos~4412. ARM cores can be configured with caches of varying sizes
decided by the implementing vendor and will have varying performance
accordingly. Thus, it is important to tune all CPU parameters so that it matches
the modeled SoC. It is not publicly known which SoC the default configuration
attempts to model, but according to the gem5 mailing list it is neither
Cortex-A9 or Cortex-A15 \cite{a15maillist}. However, the fact that it is made
for the ARMv7 instruction set and is out-of-order makes us believe minor
modifications can make it a decent model of the Cortex-A9.

The model gem5 uses in its simulations can easily be configured using a Python
interface. We started with gem5 changeset \texttt{aaf017eaad7d} and added a new
CPU configuration file for the Exynos~4412;
\texttt{gem5/configs/common/Exynos\_4412P.py}. A few other files were edited to
accomodate the new processor definition. Please refer to
\autoref{apx:gem5files} to see all patches applied in these experiments.

As implementation details for commercial processors are hidden from the end
user, the Internet can deem helpful in the search for clues. We found many
sources of information claiming to know implementation details of the Cortex-A9,
including
\cite{butko2012accuracy,blem2013detailed,armtech,exynoswiki,odroidwiki,geekland,7cpu,armcortexa9specs}.

Combining this information helps us build a gem5 model for the Exynos SoC, but
it is still not trivial.  We found the simulator to perform different from the
physical hardware, even though the system parameters are set equal. We claim
that this is due to the abstraction the simulator provides us; the simulator is
not a complete model of the hardware. Gibson et. al. \cite{gibson2000flash} have
done a similar experiment using different simulators and concluded that bugs and
omissions in system simulators may make performance tuning very difficult.

To improve our results, we adjust the model specification such that it
\textit{performs} similar to the hardware, i.e. programs execute in about the
same number of clock cycles. Even if the processor implementation would have
been completely transparent, it would still be hard to leverage the use of a
multi-architecture computer simulators. Features such as fast-loop mode found in
certain ARM cores must have a corresponding implementation in the simulator for
complete correctness; it would be infeasible to include such details in a
general simulator.

We scripted the simulator to run a wide variety of configurations, about $50$ in
total. We evaluated their performance by comparing simulated execution time to
execution time on real hardware. Real execution time were inferred by measuring
power during program executions and identify when the CPU was working. The final
CPU configuration is shown in its entirity in \autoref{gem5exynos4412p}.


\subsection{gem5 Memory Model}
The memory system is an important part of a
system simulator when doing performance estimations. At the time of writing,
gem5 will not easily work with an out-of-order CPU model together with the GEMS
Ruby memory system. Lacking other methods and considering our resources, the
simple memory system will provide events that PET can use to determine memory
and memory bus communications. The simple memory model was tuned as stated in
\autoref{gem5simpledram}.
