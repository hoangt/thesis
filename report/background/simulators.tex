\section{Hardware Simulators}

As computer architecture development meets more challenging demands, a versatile
set of software tools have been developed to help the designers. In this set of
tools lies a set of computer architecture simulators meant to evaluate
processors at the architectural level. The simulators often provides the ability
to write hardware in a language more abstract than HDL-languages, provides the
ability to run compiled binaries, and provides detailed trace logs and
performance data. The benefits of architectural simulators are many, but it is
important to find one that fits the demands given by the problem.

\subsection{A Brief Comparison}
\label{subsec:simulators}
There are numerous computer architecture simulators available to the public,
both commercial, free and open source alternatives exists. To support our power
estimation tool, a simulator frontend must provide a good picture of events
that occur in a hardware implementation of the architecture. The hardware
platform used for reference in this thesis is an out-of-order ARM Cortex-A9
based core fitted with memory and and peripherals in a von Neumann architectural
scheme. The out-of-order property significantly increases the level of
complexity which the simulator must handle.

\begin{description}
\item[Sniper] \hfill\\
    Sniper is a high-speed, multicore, multi-threaded and cycle-accurate
    computer architecture simulator \cite{sniperwebpage,carlson2013ssomta}. It
    already integrates with McPAT and it is open source. Sniper does only work
    x86, and is thus not applicable for simulation of ARM-based architectures.

\item[SimpleScalar] \hfill\\
    SimpleScalar is a popular commercial architectural simulator that comes with
    a free academic license providing full source code. SimpleScalar supports
    the ARM instruction set amongst many others, and looks like a decent
    simulator for advanced out-of-order core simulation. SimpleScalar is also
    the simulator used by the Wattch-project \cite{brooks2000wattch}. However,
    the SimpleScalar web page seems to be last updated in 2004 and all mailing
    list archives are gone at the time of writing. The source code for
    SimpleScalar v3 is still available, but has only been patched once since
    2003.

\item[QEMU]\hfill\\
    QEMU is a generic and open machine emulator which enables near real-time
    performance on architectures like ARM, even on x86 host machines. However,
    QEMU is a machine emulator rather than an architectural simulator, thus
    despite its great performance of running ARM-binaries, it will not produce
    CPU and memory event trace logs, and is not suitable for this project.

\item[gem5]\hfill\\
    gem5 is a merger between the M5 simulator \cite{binkert2006m5} and the GEMS
    simulator project \cite{GEMS}. gem5 provides ARM-support with out-of-order
    execution out of the box, and provide great cycle-accurate trace logs which
    are appropriate for this project \cite{gem5simulator}. Its core is written
    in C++ and has a highly modular interface that allows users to specify
    simulator target through simple Python scripts. Many of the maintainers are
    employees of ARM Corp., and the activity on the mailing lists suggests high
    project activity \cite{gem5dev}.
\end{description}

Provided this comparison of simulators, and given the fact that NTNU has a tradition
for using M5 and gem5 in earlier research projects and subjects, gem5 is the natural
winner for the choise of an architectural simulator.


\subsection{The gem5 Simulator}

The gem5 project \cite{gem5} merges the best features of M5 \cite{binkert2006m5}
and GEMS \cite{GEMS} and includes a wide range of CPU and memory models
\cite{gem5hipeac}. The simulator has two main execution modes; \textit{Syscall
Emulation} (SE) or \textit{Full System} (FS). In SE mode, the simulator traps
system calls in the binary and emulates them, often by passing them to the host
operating system. In FS mode, the simulator can load an operating system binary
and run application within the OS. The latter mode is well suited when the OS in
its entirety must be simulated. gem5 supports many architectures; it can run
binaries compiled for ALPHA, SPARC, MIPS, ARM, x86 and POWER architectures.

During simulation, gem5 keeps track of hundreds of events related to the CPU
core and memory system. In-detail statistics, similar to performance counters on
real hardware, are then dumped for subsequent inspection. gem5 can also output a
trace of currently activity while it runs, originally intended for debugging of
gem5. These trace logs grow quickly in size when saved to file, but provide useful
insights of the simulated execution. In particular, it describes CPU activity
down to the microarchitecture level and outputs simulated processor activity.

