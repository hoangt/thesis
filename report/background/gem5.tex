\section{The gem5 Simulator}

Joint effort between many academic and industrial institutions has resulted in
an open source computer simulation framework, the gem5 simulator \cite{gem5}.
Its core is written in C++ and has a highly modular interface that allows users
to specify simulator target through simple Python scripts.

The project merges the best features of M5 \cite{M5} and GEMS \cite{GEMS} and
includes a wide range of CPU and memory models. The simulator has two main
execution modes; \textit{Syscall Emulation} (SE) or \textit{Full System} (FS).
In SE mode, the simulator traps system calls in the binary and emulates them,
often by passing them to the host operating system. In FS mode, the simulator
can load an operating system binary and run application within the OS. The
latter mode is well suited when the OS in its entirety must be simulated.

% TODO: Write about the input to gem5 (i.e. arm binaries)

During simulation, gem5 keeps track of hundreds of events related to the CPU
core and memory system. In-detail statistics, similar to performance counters on
real hardware, are then dumped for off-line inspection. gem5 can also output a
trace of what it is currently doing, originally intended for debugging of gem5.
These traces grow quickly in size, but provide useful insights of the simulated
execution. In particular, it describes CPU activity down to the
microarchitecture level and outputs simulated processor activity.

Drawing energy profiles from the trace files can be done by simply adding a cost
to the different types of CPU activity. Finding the weights with best fit
(as compared with measurements on real hardware) is simply the problem of
parameter optimization.
